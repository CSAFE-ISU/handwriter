---
title: "Extracting Graphs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{extracting-graphs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(handwriter)
```

## Step-by-step details

1.  The first step is to load the scanned handwriting with `readPNGBinary`.
2.  Then thin, or *skeletonize*, the writing in the image to one pixel in width with `thinImage`. The output is a single column matrix of indices of the writing in the image.
3.  The work horse of graph extraction is `processHandwriting`.
    1.  Counting the number of edges connected to each pixel in the thinned writing.
    2.  Assign pixels in the thinned writing as *nodes* if they
        -   have 1 connected edge - these are labeled as *terminal nodes*
        -   3 or more connected edges or
    3.  Make a matrix `neighborhoodList` of neighbors / neighborhoods for each pixel in the thinned writing
    4.  Build a dataframe of edges where
        -   each pixel in the writing is a vertex
        -   if two vertices are neighbors there is an edge between them
    5.  Calculate the Manhattan, Euclidean, and pen distance between each vertex and its neighbor(s)
        -   Manhattan distance between each pixel and its neighbor to the top, right, bottom, or left is 1 and neighbors on the diagonals are 2.
        -   Euclidean distance between each pixel and its neighbor to the top, right, bottom, or left is 1 and to its neighbor on the diagonal is the square root of 2.
        -   The pen distance between each pixel and its neighbor to the top, right, bottom, or left is 1 and to its neighbor on the diagonal is 3.
    6.  Make a new matrix `neighborhoodList0` of neighbors / neighborhoods as in step 4, but remove neighbors on the diagonal if there are neighbors in the neighborhood on either side of the diagonal.
    7.  Build a dataframe `graphdf0` of edges from `neighborhoodList0` where
        -   each pixel in the writing is a vertex
        -   if two vertices are neighbors there is an edge between them
    8.  Calculate the node only distance for each pixel / vertex in `graphdf0`. 1 if either vertex or its neighbor is a node. 0 otherwise
    9.  `skel_graph` = undirected graph with vertices (indices) of the thinned writing and edges listed in `graphdf`. Created with the igraph package. If more than one edge connects two nodes, the edges are combined into a single edge and their weights are averaged.
    10. `skel_graph0` = undirected graph with vertices (indices) of the thinned writing and edges listed in `graphdf0`. Created with the igraph package. If more than one edge connects two nodes, the edges are combined into a single edge and their weights are averaged.
    11. Color the vertices in `skel_graph` and `skel_graph0` as 1 if the vertex is a node and 0 otherwise.
    12. Calculate the length of the shortest path between each pair of nodes in `skel_graph0` using the node only distance as the edge weights.
    13. Find nodes that are only 1 or 2 edges apart. If neither edge is terminal, merge the nodes together.
    14. Update the node only distances in `graphdf0` after merging nodes. 1 if either the vertex or its neighbor is a node and 0.00001 otherwise.
    15. Rebuild `skel_graph0`.
    16. Find all paths that are not loops.
    17. Find all paths that are loops.
    18. Rebuild `skel_graph0` with node only distance as 1 if either vertex for an edge is a node and 0 otherwise.
    19. Identify candidate graph break points for each path
        -   If the path has 10 or fewer edges, assign the middle vertex as a candidate break point and record that the path does not have a trough
        -   If the path has more than 10 edges, check each vertex in the path starting with the 5th vertex v in the list and
            -   Identify the string of vertices starting with the closest vertex from the left that is at least 2 rows higher than v to the closest vertex from the right that is at least 2 rows higher.
            -   If none of the vertices in the string from the previous step are lower (row-wise) than v, then v is a trough node and record that the path has a trough
        -   find the trough nodes where: (1) the row of the trough node is not equal to the row of the next trough node, or (2) the column of the trough node is different than the column of the next trough node minus 1, and (3) the column of the trough node minus 1 is not equal to the column of the text trough node.
        -   Divide the index of the trough nodes in half and add them to the list of candidate break points. WHY are the indices divided in half?
    20. For each path, if the path contains a candidate break point, check if (1) there is more than one route between the first and last nodes in the path, (2) if the path contains a terminal node (3) if the candidate break point is within 4 of the first or last node in the path, and (4) if the path contains 10 or fewer vertices. If any of these 4 conditions are true, the DO NOT create a break point at the candidate.
